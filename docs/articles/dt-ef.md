# DataExplorer.EfCore

[![Build Status](https://github.com/MikyM/DataExplorer/actions/workflows/release.yml/badge.svg)](https://github.com/MikyM/DataExplorer/actions)

Library featuring an opinionated, reusable data access layer offering abstractions and implementations for SQL storages (EF Core) and MongoDb (MongoDb.Entities).

## Installation

Base DataExplorer package is required.

To register the library services with the DI container use the DataExplorerConfiguration extension method provided by the library:

```csharp
builder.AddDataExplorer(options => 
{
    options.AddEfCore(assembliesToScan);
});
```

## Description

Library provides definition of a base entity (with generic Id and with long Id) which should be inherited by any entity defined within application's domain.

```csharp
public class CustomEntity : Entity<long>
{
    public bool CustomField { get; set; }
}
```

Library supports soft deletion via a `IsDisabled` property on entities, you can mark an entity as a soft deleted entity using `IDisableableEntity` interface.
Snowflake IDs are supported using an IdGenerator, to mark an entity to use snowflake IDs inherit from `SnowflakeEntity` or implement `ISnowflakeEntity` interface and override the Id property. Ids can be generated by a provided `IdGenerator` which you can add as a singleton service via `AddIdGen()`

To avoid LINQ boilerplate a specification pattern is used to encapsulate query logic and should be used like so:
```csharp
public CustomSpecification : ISpecification<CustomEntity>
{
    public CustomSpecification(bool customField)
    {
        Where(x => x.CustomField == customField);
    }
}
```

Please use IntelliSense to check for available methods but pretty much everything should be supported by now.

Every data service automatically grabs it's corresponding entity repository from the Unit of Work and exposes it via properties, you can however do anything and everything through exposed DbContext, UnitOfWork, Mapper and other properties.

Getting a repository is done through methods on `IUnitOfWork`:
```csharp
unitOfWork.GetRepository<IRepository<CustomEntity>>();
```
Please use IntelliSense to find other helpful get repo methods. You can't (without reflection magic) create custom repository implementations, their constructor is internal, you can only get generic repos with the methods exposed via `IUnitOfWork`, any custom, additional logic, should be performed in the service layer.:

Given below context definitions (always abstract your own context) - either manually register your context interface as a service or use `AddDbContext` methods on `DataExplorerEfCoreConfiguration`.
```csharp
public interface ICustomDbContext : IEfDbContext
{
}

public class CustomDbContext : EfDbContext, ICustomDbContext
{
}
```

You can define a crud data service like so to add some custom logic:

```csharp
public interface ICustomDataService : ICrudDataService<CustomEntity, ICustomDbContext>
{
    Task<Result> GetFirstEntityWithCustomFieldTrueAndPerformLogicAsync();
}

public class CustomDataService : CrudDataService<CustomEntity, ICustomDbContext>, ICustomDataService
{
    public async Task<Result> GetFirstEntityWithCustomFieldTrueAndPerformLogicAsync()
    {
        var entityRes = await GetSingleBySpecAsync(new CustomSpecification(true));

        if (!entityRes.IsDefined(out var entity))
            return entityRes;

        /// perform custom logic on entity or whatnot

        return Result.FromSuccess();
    }
}
```

You can also simply inject a generic data service to perform simple operations like so:
```csharp

public class CustomController : ControllerBase
{
    private readonly IReadOnlyDataService<CustomEntity,ICustomDbContext> _dataService;

    public CustomController(IReadOnlyDataService<CustomEntity,ICustomDbContext> dataService)
        => _dataService = dataService;

    [HttpGet]
    public async Task<IActionResult> GetAllByCustomFieldAsync(bool customField)
    {
        var subRes = await _dataService.GetBySpecAsync(new CustomSpecification(customField)); // or GetBySpecAsync<SomeDto> to automatically map the entity using AutoMapper
        if (!subRes.IsDefined(out var result))
            return BadRequest();

        return Ok(result);
    }
}
```

All service methods should return a [Result](https://github.com/Remora/Remora.Results) struct which determines whether the operation succeeded or not and returns additional objects if necessary and shouldn't throw exceptions unless absolutely necessary.
