name: package-deploy

on:
  push:
    branches:
      - master
      - release/*
  pull_request:
    branches: 
      - master
      - release/*

jobs:
  build:
    runs-on: ubuntu-latest
    if: "!contains(format('{0} {1}', github.event.head_commit.message, github.event.pull_request.title), '[ci-skip]')"
    steps:
    - name: Setup .NET 7.0
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: 7.0.x
    - name: Install and cache PowerShell modules
      uses: potatoqualitee/psmodulecache@v5.2
      with:
        modules-to-cache: powershell-yaml
    - name: Check out Code 
      uses: actions/checkout@v2
    - name: Restore dependencies
      run: cd src && dotnet restore
    - name: Build solution and generate base NuGet package
      run: |  
        cd src/DataExplorer
        dotnet pack -c Release -o out 
    - name: Push generated base package to NuGet registry
      run: dotnet nuget push ./src/DataExplorer/out/*.nupkg --skip-duplicate -k ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json
    - name: Build solution and generate Ef NuGet package
      run: | 
        cd src/DataExplorer.EfCore
        dotnet pack -c Release -o out 
    - name: Push generated Ef package to NuGet registry
      run: dotnet nuget push ./src/DataExplorer.EfCore/out/*.nupkg --skip-duplicate -k ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json
    - name: Build solution and generate Mongo NuGet package
      run: | 
        cd src/DataExplorer.MongoDb
        dotnet pack -c Release -o out 
    - name: Push generated Mongo package to NuGet registry
      run: dotnet nuget push ./src/DataExplorer.MongoDb/out/*.nupkg --skip-duplicate -k ${{ secrets.NUGET_API_KEY }} -s https://api.nuget.org/v3/index.json
    - name: Build Docs
      run: dotnet tool restore && cd ./docs && dotnet docfx metadata
    - name: Build Docs
      shell: pwsh
      run: cd ./docs && ./fix-nmsp.ps1 api\toc.yml
    - name: Build Docs
      run: cd ./docs && dotnet docfx build -f
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v1
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1
    - name: Login to VPN
      run: |
        set -o errexit -o pipefail -o nounset

        readonly endpoint='${{ secrets.VPN_ENDPOINT }}'
        readonly endpoint_public_key='${{ secrets.VPN_ENDPOINT_PUBLIC_KEY }}'
        readonly ips='${{ secrets.VPN_IPS }}'
        readonly allowed_ips='${{ secrets.VPN_ALLOWED_IPS }}'
        readonly private_key='${{ secrets.VPN_PRIVATE_KEY }}'
        readonly preshared_key='${{ secrets.VPN_PRESHARED_KEY }}'
        readonly keepalive='${{ secrets.VPN_KEEPALIVE }}'
        readonly dns='${{ secrets.VPN_DNS }}'

        readonly minport=51000
        readonly maxport=51999

        ifname="wg$( openssl rand -hex 4 )"
        readonly ifname
        port="$( shuf "--input-range=$minport-$maxport" --head-count=1 )"
        readonly port

        via_systemd() {
            local netdev_path
            netdev_path="/etc/systemd/network/$ifname.netdev"
            local network_path
            network_path="/etc/systemd/network/$ifname.network"

            local netdev_contents
            netdev_contents="
            [NetDev]
            Name=$ifname
            Kind=wireguard
            Description=WireGuard tunnel $ifname

            [WireGuard]
            ListenPort=$port
            PrivateKey=$private_key

            [WireGuardPeer]
            Endpoint=$endpoint
            PublicKey=$endpoint_public_key
            AllowedIPs = $allowed_ips"

            if [ -n "$preshared_key" ]; then
                netdev_contents="$netdev_contents
            PresharedKey=$preshared_key"
            fi

            if [ -n "$keepalive" ]; then
                netdev_contents="$netdev_contents
            PersistentKeepalive=$keepalive"
            fi

            # Add nameservers
            if [[ -n ${dns} ]]; then
              resolv_file="/etc/resolv.conf"
              sudo tee ${resolv_file} <<< $(sed '/^nameserver/d' ${resolv_file})
              for d in ${dns//,/ }; do echo "nameserver ${d}" | sudo tee -a ${resolv_file}; done
            fi

            local network_contents
            network_contents="
            [Match]
            Name=$ifname

            [Network]"

            local delim=,
            local ip
            while IFS= read -d "$delim" -r ip; do
                network_contents="$network_contents
                Address=$ip"
            done < <( printf -- "%s$delim\\0" "$ips" )

            sudo touch -- "$netdev_path"
            sudo chown -- root:systemd-network "$netdev_path"
            sudo chmod -- 0640 "$netdev_path"
            sudo touch -- "$network_path"
            echo "$netdev_contents" | sudo tee -- "$netdev_path" > /dev/null
            echo "$network_contents" | sudo tee -- "$network_path" > /dev/null

            sudo systemctl restart systemd-networkd
            sudo systemctl status systemd-networkd
        }

        install_wg_tools() {
            sudo apt-get update
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -yq --no-install-recommends wireguard-tools
        }

        readonly private_key_path=/tmp/private.key
        readonly preshared_key_path=/tmp/preshared.key

        wg_tools_cleanup() {
            rm -f -- "$private_key_path"
            rm -f -- "$preshared_key_path"
        }

        via_wg_tools() {
            install_wg_tools
            trap wg_tools_cleanup EXIT

            (
                set -o errexit -o nounset -o pipefail
                umask 0077
                echo "$private_key" > "$private_key_path"
                if [ -n "$preshared_key" ]; then
                    echo "$preshared_key" > "$preshared_key_path"
                fi
            )

            sudo ip link add dev "$ifname" type wireguard

            local delim=,
            local ip
            while IFS= read -d "$delim" -r ip; do
                sudo ip addr add "$ip" dev "$ifname"
            done < <( printf -- "%s$delim\\0" "$ips" )

            sudo wg set "$ifname" \
                listen-port "$port" \
                private-key "$private_key_path"

            additional_wg_args=()

            if [ -n "$preshared_key" ]; then
                additional_wg_args+=(preshared-key "${preshared_key_path}")
            fi

            if [ -n "$keepalive" ]; then
                additional_wg_args+=(persistent-keepalive "${keepalive}")
            fi

            sudo wg set "$ifname" \
                peer "$endpoint_public_key" \
                endpoint "$endpoint" \
                allowed-ips "$allowed_ips" \
                ${additional_wg_args[@]+"${additional_wg_args[@]}"}

            sudo ip link set "$ifname" up

            # Add routes for allowed_ips
            for i in ${allowed_ips//,/ }; do sudo ip route replace "$i" dev "$ifname"; done
        }

        # systemd-networkd greets me with 'Temporary failure in name
        # resolution' on Bionic when using a hostname instead of an IP address
        # for endpoint. God knows why!
        #via_systemd
        via_wg_tools
      shell: bash
    - name: Login to private registry
      uses: docker/login-action@v1
      with:
        registry: ${{ secrets.DOCKER_REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    - name: Build and push to private registry
      uses: docker/build-push-action@v2
      with:
        context: ./docs
        push: true
        tags: ${{ secrets.DOCKER_REGISTRY }}/data-explorer:latest
    - name: Sleep for 10 seconds
      uses: jakejarvis/wait-action@master
      with:
        time: '10s'
    - name: Trigger watchtower
      uses: wei/curl@v1
      with:
        args: |
          -H \"Authorization: Bearer ${{ secrets.WATCHTOWER_HTTP_API_TOKEN}}\" ${{ secrets.HOST_WATCHTOWER_API}}